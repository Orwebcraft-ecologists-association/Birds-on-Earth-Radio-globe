// Minimal Three.js stub for Birds Radio Globe
// This is a simplified implementation to demonstrate the concept

window.THREE = {
    // Basic color constants
    Color: function(hex) {
        this.r = ((hex >> 16) & 255) / 255;
        this.g = ((hex >> 8) & 255) / 255;
        this.b = (hex & 255) / 255;
        this.getHex = function() { return hex; };
        return this;
    },

    // Scene object
    Scene: function() {
        this.children = [];
        this.background = null;
        this.add = function(object) {
            this.children.push(object);
        };
        this.remove = function(object) {
            const index = this.children.indexOf(object);
            if (index > -1) this.children.splice(index, 1);
        };
        return this;
    },

    // Camera
    PerspectiveCamera: function(fov, aspect, near, far) {
        this.fov = fov;
        this.aspect = aspect;
        this.near = near;
        this.far = far;
        this.position = { x: 0, y: 0, z: 5 };
        this.updateProjectionMatrix = function() {};
        return this;
    },

    // Renderer (Canvas-based fallback)
    WebGLRenderer: function(options) {
        this.domElement = options.canvas || document.createElement('canvas');
        this.shadowMap = { enabled: false, type: null };
        
        this.setSize = function(width, height) {
            this.domElement.width = width;
            this.domElement.height = height;
            this.domElement.style.width = width + 'px';
            this.domElement.style.height = height + 'px';
        };
        
        this.setPixelRatio = function(ratio) {};
        
        this.render = function(scene, camera) {
            // Simple 2D canvas rendering fallback
            const ctx = this.domElement.getContext('2d');
            const width = this.domElement.width;
            const height = this.domElement.height;
            
            // Clear canvas
            ctx.fillStyle = '#000a0f';
            ctx.fillRect(0, 0, width, height);
            
            // Draw globe
            const centerX = width / 2;
            const centerY = height / 2;
            const radius = Math.min(width, height) * 0.3;
            
            // Globe gradient
            const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
            gradient.addColorStop(0, '#2a5298');
            gradient.addColorStop(0.7, '#1e3c72');
            gradient.addColorStop(1, '#0f1419');
            
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
            ctx.fillStyle = gradient;
            ctx.fill();
            
            // Draw atmosphere glow
            const glowGradient = ctx.createRadialGradient(centerX, centerY, radius, centerX, centerY, radius * 1.2);
            glowGradient.addColorStop(0, 'rgba(32, 128, 255, 0.3)');
            glowGradient.addColorStop(1, 'rgba(32, 128, 255, 0)');
            
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius * 1.2, 0, 2 * Math.PI);
            ctx.fillStyle = glowGradient;
            ctx.fill();
            
            // Draw markers from scene
            scene.children.forEach(child => {
                if (child.userData && child.position) {
                    const x = centerX + child.position.x * radius * 0.8;
                    const y = centerY - child.position.y * radius * 0.8;
                    
                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, 2 * Math.PI);
                    
                    if (child.userData.type === 'bird') {
                        ctx.fillStyle = '#4CAF50';
                    } else {
                        ctx.fillStyle = '#FF5722';
                    }
                    
                    ctx.fill();
                    
                    // Add glow effect
                    ctx.shadowColor = ctx.fillStyle;
                    ctx.shadowBlur = 10;
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
            });
        };
        
        return this;
    },

    // Geometry classes
    SphereGeometry: function(radius, widthSegments, heightSegments) {
        this.radius = radius;
        this.widthSegments = widthSegments;
        this.heightSegments = heightSegments;
        return this;
    },

    // Material classes
    MeshPhongMaterial: function(options) {
        Object.assign(this, options);
        return this;
    },

    MeshBasicMaterial: function(options) {
        Object.assign(this, options);
        return this;
    },

    ShaderMaterial: function(options) {
        Object.assign(this, options);
        return this;
    },

    // Mesh class
    Mesh: function(geometry, material) {
        this.geometry = geometry;
        this.material = material;
        this.position = { x: 0, y: 0, z: 0 };
        this.rotation = { x: 0, y: 0, z: 0 };
        this.quaternion = { 
            x: 0, y: 0, z: 0, w: 1,
            multiplyQuaternions: function(a, b) {
                // Simplified quaternion multiply
                return this;
            }
        };
        this.userData = {};
        this.receiveShadow = false;
        this.castShadow = false;
        return this;
    },

    // Lights
    AmbientLight: function(color, intensity) {
        this.color = new THREE.Color(color);
        this.intensity = intensity;
        return this;
    },

    DirectionalLight: function(color, intensity) {
        this.color = new THREE.Color(color);
        this.intensity = intensity;
        this.position = { x: 0, y: 0, z: 0, set: function(x, y, z) { this.x = x; this.y = y; this.z = z; } };
        this.castShadow = false;
        this.shadow = { mapSize: { width: 2048, height: 2048 } };
        return this;
    },

    PointLight: function(color, intensity, distance) {
        this.color = new THREE.Color(color);
        this.intensity = intensity;
        this.distance = distance;
        this.position = { x: 0, y: 0, z: 0, set: function(x, y, z) { this.x = x; this.y = y; this.z = z; } };
        return this;
    },

    // Texture
    CanvasTexture: function(canvas) {
        this.image = canvas;
        return this;
    },

    // Raycaster for click detection
    Raycaster: function() {
        this.setFromCamera = function(mouse, camera) {};
        this.intersectObjects = function(objects) {
            // Simplified click detection
            return [];
        };
        return this;
    },

    // Vector2 for mouse coordinates
    Vector2: function(x, y) {
        this.x = x || 0;
        this.y = y || 0;
        return this;
    },

    // Euler angles
    Euler: function(x, y, z, order) {
        this.x = x || 0;
        this.y = y || 0;
        this.z = z || 0;
        this.order = order || 'XYZ';
        return this;
    },

    // Quaternion
    Quaternion: function() {
        this.x = 0;
        this.y = 0;
        this.z = 0;
        this.w = 1;
        this.setFromEuler = function(euler) { return this; };
        this.multiplyQuaternions = function(a, b) { return this; };
        return this;
    },

    // Constants
    PCFSoftShadowMap: 'PCFSoftShadowMap',
    AdditiveBlending: 'AdditiveBlending',
    BackSide: 'BackSide'
};